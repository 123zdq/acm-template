# 数学



## 模乘模幂

* longlong范围用fpl

```cpp
inline LL mul(LL a, LL b, LL p) {
    LL res = a * b - ((LL)((LD)a * b / p) * p);
    return res < 0 ? res + p : (res < p ? res : res - p);
}

inline LL fp(LL a, LL b, LL Mod) {
    LL res = (Mod != 1);
    for (; b; b >>= 1, a = a * a % Mod)
        if (b & 1)
            res = res * a % Mod;
    return res;
}

inline LL fpl(LL a, LL b, LL Mod) {
    LL res = (Mod != 1);
    for (; b; b >>= 1, a = mul(a, a, Mod))
        if (b & 1)
            res = mul(res, a, Mod);
    return res;
}
```



## GCD

```cpp
template <typename T>
inline T gcd(T a, T b) {
	while (b){
		T t = b;
		b = a % b;
		a = t;
	}
	return a;
}

template <typename T>
inline T lcm(T a, T b) { return a / gcd(a, b) * b; }

template<typename T>
inline T exgcd(T a,T b,T&x,T&y){
    x=1,y=0;T m=0,n=1;
    while(b){
        const T q=a/b;
        tie(x,m)=make_tuple(m,x-q*m);
        tie(y,n)=make_tuple(n,y-q*n);
        tie(a,b)=make_tuple(b,a-q*b);
    }
    return a;
}
```



## CRT
* 需要 `GCD` `64位模乘`
* 用来合并同余方程 
* 返回最小正数解或最小非负解  无解返回`-1`

```cpp
inline LL Crt(LL a1, LL a2, LL mod1, LL mod2) {
    LL u, v;
    LL g = exgcd(mod1, mod2, u, v);
    if ((a2 - a1) % g) return -1;
    LL m12 = abs(lcm(mod1, mod2));
    LL res = (mul(mod1, mul(u, ((a2 - a1) / g), m12), m12) + a1) % m12;
    return res <= 0 ? res + m12 : res; /*求最小正数解还是非负解*/
}
```



## 高次同余方程

* 以下 `p` 均为正整数

### BSGS

* 求最小非负整数x 满足 `a^x=b(mod p)`  

* 要求 `(a,p)=1`  `p`不必是质数 无解返回 $-1$ 

* 需要 `fp` 和 `map/unorded_map`  如果p超过1e9用LL版本

* 期望复杂度 $O(\sqrt{p})$​   

* 自带哈希可以被卡TLE (luogu P4192) 

* * 用 `map`   复杂度多个log  慢

* * 手写整数哈希  `unordered_map<int,int,custom_hash>h;`

* 若多组询问a,p不变 且始终满足(b,p)=1 可以复用h降低复杂度 

```cpp
inline int log_p(int a, int b, int p){
    if ((b - 1) % p == 0)return 0;
    if ((b - a) % p == 0)return 1;
    //在%p前特判 此后满足p>1且result>1
    a %= p; (a < 0) && (a += p);
    b %= p; (b < 0) && (b += p);
    //assert(abs(gcd(a,p))==1);//调用时保证a⊥p则此行可省
    unordered_map<int, int> h; //仔细判断出题人卡不卡
    int t = (int)sqrt(p) + 1;
    for (int j = 0; j < t; ++j, b = (LL)b * a % p) h[b] = j;
    int at = (a = fp(a, t, p));
    for (int i = 1, j = t; i <= t; ++i, a = (LL)a * at % p, j += t){
        auto bat = h.find(a);
        if (bat != h.end()) return j - (*bat).second;
    } return -1;
}
```

### EXBSGS

* 求最小非负整数x 满足 `a^x=b(mod p)`  

* 不要求正整数a,p互质 无解返回 $-1$ 

* 注意乘法溢出

```cpp
inline int getinv(int a, int p){
    int m = 0, n = 1, x = 1, y = 0, b = p;
    while (b){
        int q = a / b;
        tie(x, m) = make_tuple(m, x - q * m);
        tie(y, n) = make_tuple(n, y - q * n);
        tie(a, b) = make_tuple(b, a - q * b);
    }
    x %= p; (x < 0) && (x += p);
    return x;
}

inline int log(int a,int b,int p){
    if ((b - 1) % p == 0)return 0;
    if ((b - a) % p == 0)return 1;
    a %= p; (a < 0) && (a += p);
    b %= p; (b < 0) && (b += p);
    int _a = a, _b = b, _p = p;
	int d = gcd(a, p), ax = 1, t = 0;
    while (d > 1){
        if (b % d != 0)break; //若b不能再提出d 说明result<=t
        b /= d; p /= d; ax = (LL)ax * (a / d) % p;
        ++t;
        d = gcd(a, p);
    }
    for (int i = 2, at = (LL)_a * _a % _p; i <= t; ++i, at = (LL)at * _a % _p)
        if (at == _b) return i;
    if (d > 1) return -1;
    int res = log_p(a, (LL)b * getinv(ax, p) % p, p);
    return res < 0 ? -1 : res + t;
}
```

### 二次剩余

#### 判定定理

* p是奇素数 且 n和p互质

* $n^{\frac{p-1}{2}}mod\ p=\begin{cases}1 \qquad & n是二次剩余 \\ -1 \qquad &  n是非二次剩余 \end{cases}$

#### Cipolla算法

* 寻找非负整数 $x$ 满足 $x^2\equiv n \left( mod\ p\right)$ 其中 $p$ 为质数

* 期望复杂度 O(log p) 

* 需要用到快速幂`fp()` 若p大于1e9要换 `mul()` 和 `fpl()`  

* 注意乘法溢出

* * 先找到 $a$ 使 $a^2-n$ 是非二次剩余 

* * 定义 $w=i^2=a^2-n$ 则 $x=(a+i)^{\frac{p+1}{2}}$

* 无解返回 $-1$ 

```CPP
namespace Cipolla{
	LL w,p,d;
    
	struct dat{
		LL x,y;//复数 x+yi
		dat operator*(const dat&a)const{
			return(dat){(x*a.x+y*a.y%p*w)%p,(x*a.y+y*a.x)%p};
		}
	};
    
	inline LL ask(LL n,LL P){//n为非二次剩余返回-1
		p=P;n%=p;if(n==0||p==2)return n;
		d=(p-1)/2;
		if(fp(n,d,p)!=1)return -1;//检验是否有解
		LL a;
		while(1){
			a=(LL)rand()*rand()%p;
			w=(a*a-n)%p;(w<0)&&(w+=p);
			if(fp(w,d,p)==(p-1))break;//找到了非二次剩余w
		}
		dat res={1,0};++d;
		for(dat u={a,1};d;d>>=1,u=u*u)if(d&1)res=res*u;
		return res.x;
	}
}

signed main(){//luogu P5491
	int t;scanf("%d",&t);
	while(t--){
		LL n,p;scanf("%lld%lld",&n,&p);
		LL ans=Cipolla::ask(n,p);
		if(ans==-1)puts("Hola!");
		else if(ans==0)puts("0");
        else printf("%lld %lld\n",min(ans,p-ans),max(ans,p-ans));
	}
	return 0;
}
```



## 线性筛

```cpp
struct primenumberlist{
#define MAXN (100000000)
	int cnt, pri[10000000]; 
	bool np[MAXN + 10];
	primenumberlist(){
		np[1] = 1; cnt = 0;
		for (int i = 2; i <= MAXN; ++i) {
			if (!np[i]) pri[++cnt] = i;
			for (int j = 1; j <= cnt; ++j) {
				LL t = pri[j] * i;
				if (t > MAXN) break;
				np[t] = 1;
				if (!(i % pri[j])) break;
			}
		}
	}
} prime;
```



## φ 单点欧拉函数
```cpp
template <typename T>
inline T phi(T x) {
	T res = x;
	for (T i = 2; i * i <= x; ++i)
		if ((x % i) == 0) {
			res = res / i * (i - 1);
			while ((x % i) == 0) x /= i;
		}
	if (x > 1) res = res / x * (x - 1);
	return res;
}
```



## Miller-Rabin素性测试

* $n<=10^{18}$

* 需要 `64位模乘` `64位模幂`

```cpp
inline bool MR(LL x, LL n, int t) {
    LL las = x;
    for (int i = 1; i <= t; ++i) {
        x = mul(x, x, n);
        if (x == 1 && las != 1 && las != (n - 1)) return 0;
        las = x;
    }
    return x == 1;
}

inline bool isPrime(LL n) {
    if (n == 46856248255981ll || n < 2) return 0;
    if (n == 2 || n == 3 || n == 7 || n == 61 || n == 24251) return 1;
    LL d = n - 1;
    int t = 0;
    while ((d & 1) == 0) d >>= 1, ++t;
    return MR(fpl(2, d, n), n, t) && MR(fpl(61, d, n), n, t);
}
```



## Pollard-Rho 分解质因数

* 需要 `64位模乘` `gcd`

* 求 $n$ 的一个大于1的因子 可能返回n本身 

* 调用 `PR()` 前务必判断 $n$ 的素性 检查 $n>1$

```cpp
mt19937 mt(time(0)); //随机化
inline LL PR(LL n) {
    LL x = uniform_int_distribution<LL>(0, n - 1)(mt), s, t, c = uniform_int_distribution<LL>(1, n - 1)(mt); //随机化
    for (int gol = 1; 1; gol <<= 1, s = t, x = 1) {
        for (int stp = 1; stp <= gol; ++stp) {
            t = (mul(t, t, n) + c) % n;
            x = mul(x, abs(s - t), n);
            if ((stp & 127) == 0) {
                LL d = gcd(x, n);
                if (d > 1) return d;
            }
        }
        LL d = gcd(x, n);
        if (d > 1) return d;
    }
}
```



## 组合数

* 数较小 模数为较大质数  求逆元 

* * 如果模数固定可以 O(n)预处理阶乘的逆元

* 数较大 模数为较小质数  用 $Lucas$ 定理

* * $$C_n^m\equiv C_{\lfloor \frac np\rfloor}^{\lfloor \frac mp\rfloor}*C_{n\ mod\ p}^{m\ mod\ p}(mod\  p)$$

* 数较大 模数较小 用 $exLucas$ 定理求  $C_n^m mod\ P$

### exLucas

* 需要`模乘` `CRT`

* O(P log P)  

* 不要求P为质数

```CPP
namespace EXLUCAS {
	inline LL idxp(LL n, LL p) {
		LL nn = n;
		while (n > 0) nn -= (n % p), n /= p;
		return nn / (p - 1);
	}

	LL facp(LL n, LL p, LL pk) {
		if (n == 0) return 1;
		LL res = 1;
		if (n >= pk) {
			LL t = n / pk, k = 1, els = n - t * pk;
			for (LL i = 1; i <= els; ++i) if (i % p) k = k * i % pk;
			res = k;
			for (LL i = els + 1; i < pk; ++i) if (i % p) k = k * i % pk;
			res = res * fp(k, n / pk, pk) % pk;
		}
		else for (LL i = 1; i <= n; ++i) if (i % p) res = res * i % pk;
		return res * facp(n / p, p, pk) % pk;
	}

	inline LL exlucas(LL n, LL m, LL p, LL pk, LL k) {
		LL a = facp(n, p, pk) * fp(facp(n - m, p, pk) * facp(m, p, pk) % pk, pk / p * (p - 1) - 1, pk) % pk;
		LL b = idxp(n, p) - idxp(m, p) - idxp(n - m, p);
		if (b >= k) return 0;
		while (b--) a *= p;
		return a % pk;
	}

	/*接口*/ inline LL exlucas(LL n, LL m, LL p) {
		LL a = 0, b = 1;
		for (LL i = 2; i * i <= p; ++i) {
			if (p % i) continue;
			LL t = 0, pk = 1;
			while (p % i == 0) ++t, p /= i, pk *= i;
			a = Crt(a, exlucas(n, m, i, pk, t), b, pk);
			b *= pk;
		}
		return (p > 1) ? Crt(a, exlucas(n, m, p, p, 1), b, p) : a;
	}
}
```



## 类欧几里得算法

* 计算直线下整点数

* `f=∑[(ai+b)/c]`  `g=∑i[(ai+b)/c]`  `h=∑[(ai+b)/c]^2`  `i=0..n  a,b,n∈N  c∈N*`

* 复杂度`log(MAX{a,c})`

```cpp
struct dat{LL f, g, h;};
const LL i2 = 499122177, i3 = 332748118, M = 998244353; //预处理出模M意义下2和3的逆元
dat f(LL a, LL b, LL c, LL n){
    LL ac = a / c, bc = b / c;
    LL n2 = (n * (n + 1) % M) * i2 % M, n3 = n2 * (2ll * n + 1) % M * i3 % M;
    dat res = {
        (n2 * ac % M + (n + 1) * bc % M) % M, 
        (ac * n3 % M + bc * n2 % M) % M, 
        (ac * ac % M * n3 % M + 
            bc * bc % M * (n + 1) % M + ac * bc % M * n2 % M * 2ll) % M};
    a %= c; b %= c; if (a == 0)return res;
    LL m = (a * n + b) / c;
    dat p = f(c, c - b - 1, a, m - 1);
    LL fc = (n * m % M - p.f + M) % M, gc = (n2 * m % M - i2 * (p.f + p.h) % M + M) % M;
    return{(res.f + fc) % M,    (res.g + gc) % M, 
    (res.h + 2ll * (bc * fc % M + ac * gc % M) % M + 
        n * m % M * m % M - 2ll * p.g - p.f + 3ll * M) % M};}
```



## 多项式乘法FFT

* fft计算卷积 复杂度O(nlogn)  luogu P3803

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2100009;

//fft计算卷积 复杂度O(nlogn)  luogu P3803
namespace FFT{
    const double PI=acos(-1.0);
    struct comp{
        double x,y;
        comp(double _x=0,double _y=0):x(_x),y(_y){}
        comp operator+(const comp&a)const{return comp(x+a.x,y+a.y);}
        comp operator-(const comp&a)const{return comp(x-a.x,y-a.y);}
        comp operator*(const comp&a)const{return comp(x*a.x-y*a.y,x*a.y+y*a.x);}
    };
    int rev[N];//位逆序置换  
    inline void getrev(int len){//每次len变化应重新计算rev
        const int d=len>>1;
        for(int i=1;i<len;++i)rev[i]=(rev[i>>1]>>1)|((i&1)*d);
    }
    
    inline void dft(comp y[],int len,int on){//on==1 DFT   on==-1 IDFT
        for(int i=1;i<len;++i)if(i<rev[i])swap(y[i],y[rev[i]]);
        for(int mid=1;mid<len;mid<<=1){
            comp wn(cos(PI/mid),on*sin(PI/mid));
            for(int st=0,t=(mid<<1);st<len;st+=t){
                comp w(1,0);
                for(int i=st,j=st+mid;j<st+t;++i,++j,w=w*wn){
                    comp u=y[i],v=w*y[j];
                    y[i]=u+v;y[j]=u-v;
                }
            }
        }
        if(on==-1)for(int i=0;i<len;++i)y[i].x/=len,y[i].y/=len;//保证结果在R上可只除实部
    }
}

int n,m;
FFT::comp f1[N],f2[N];
signed main(){
    scanf("%d%d",&n,&m);
    for(int i=0;i<=n;++i)scanf("%lf",&f1[i].x);
    for(int i=0;i<=m;++i)scanf("%lf",&f2[i].x);
    int len=1;while(len<=m+n)len<<=1;FFT::getrev(len);
    FFT::dft(f1,len,1);FFT::dft(f2,len,1);
    for(int i=0;i<len;++i)f1[i]=f1[i]*f2[i];
    FFT::dft(f1,len,-1);
    for(int i=0;i<=n+m;++i)printf("%d ",(int)(f1[i].x+0.5));
    return 0;
}
```



## 数值积分

* 自适应辛普森算法 复杂度 O(看玄学调参)

* luogu p4542

```cpp
#include<bits/stdc++.h>
using namespace std;

struct integration{//∫f(x)dx≈(r−l)*(f(l)+f(r)+4*f((l+r​)/2)​)/6
	typedef double T;
	const T EPS=(1e-6)*15;

	T aa,bb,cc,dd;
	integration(T _a,T _b,T _c,T _d):aa(_a),bb(_b),cc(_c),dd(_d){}

	T f(T x)const{//被积函数f(x)
		return (cc*x+dd)/(aa*x+bb);
	}

	T simpson(T len,T l,T mid,T r)const{//时间优化 传入算好的函数值
		return len*(l+4*mid+r)/6;
	}
	T asr(T l,T r,T a,T c,T e,int stp)const{
		const T len=r-l,mid=l+len/2,lmid=l+len/4,rmid=mid+len/4;
		const T b=f(lmid),d=f(rmid);
		const T L=simpson(len/2,a,b,c),R=simpson(len/2,c,d,e),o=L+R-simpson(len,a,c,e);
		return (abs(o)<=EPS&&stp<0)?(L+R+o/15):asr(l,mid,a,b,c,stp-1)+asr(mid,r,c,d,e,stp-1);
	}
	T operator()(T l,T r)const{return asr(l,r,f(l),f(l+(r-l)/2),f(r),6);}//最小迭代次数
};

signed main(){
	double a,b,c,d,l,r;
	scanf("%lf%lf%lf%lf%lf%lf",&a,&b,&c,&d,&l,&r);
	integration F(a,b,c,d);
	printf("%.6lf\n",F(l,r));
	return 0;
}
```



## 日期操作

### 用于跳转的常量

```cpp
const LL year_1[2]={365, 366};
const LL year_400=1460097;
const LL m_day[13]={(LL)0x3f3f3f, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
```

### 辅助函数

```cpp
inline bool isLeap(LL t){return (t % 400 == 0) ||((t % 4 == 0) && (t % 100));}
inline bool pick(LL a, LL b){return ((isLeap(a) && b <= 2) ||(isLeap(a + 1) && b > 2));}
inline LL dayThisMonth(LL y, LL m){return m_day[m] + isLeap(y) * (m == 2);}
```

### 日期和整数的一一对应

* LL可以改成int

```cpp
struct MY_DATE{
    LL year, month, day;
    MY_DATE(LL y = 2021, LL m = 1, LL d = 1) : year(y), month(m), day(d){};
    LL p(MY_DATE op = {0, 0, 0}){//日期转换为整数
        LL y = year - op.year, m = month - op.month, d = day - op.day;
        if (m <= 2){ y--; m += 12;}
        return 365 * y + y / 4 - y / 100 + y / 400 + (153 * (m - 3) + 2) / 5 + d - 307;
    }
    MY_DATE run(LL k){//当前日期过k天
        k += p();
        LL x = k + 1789995, n = 4 * x / 146097, i, j, d;
        x -= (146097 * n + 3) / 4;
        i = (4000 * (x + 1)) / 1461001;
        x -= 1461 * i / 4 - 31;
        j = 80 * x / 2447;
        d = x - 2447 * j / 80;
        x = j / 11;
        return MY_DATE(100 * (n - 49) + i + x, j + 2 - 12 * x, d);
    }
};
```
